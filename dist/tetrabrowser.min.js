/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Utils = {
  fetch: window.fetch,

  shallowDefaultOverride: function (defaults) {
    var key, desc, j;
    var settings = Object.create(null);
    var getSymbols = Object.getOwnPropertySymbols || false; // Only in ECMA6
    var properties = Object.getOwnPropertyNames(defaults)
        .concat(getSymbols ? getSymbols(defaults) : []);
    var i = properties.length;
    

    while (i--) {
      key = properties[i];
      Object.defineProperty(settings, key, Object.getOwnPropertyDescriptor(defaults, key));

      // Override the default with any settings specified in {arguments}
      j = 0; // Skip <obj> but get all others
      while (++j < arguments.length) {
        desc = Object.getOwnPropertyDescriptor(arguments[j], key);
        if (desc != 'undefined')
          Object.defineProperty(settings, key, desc);
      }
    }
    return settings;
  },

  nullFunction: function () {},
  responseText: function (data) { return data.text(); },
  responseJSON: function (data) { return data.json(); },

  printArgs: function () {
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i < args.length; ++i) {
      console.log(args[i]);
    }
  },

};

module.exports = Utils;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

// Useful link regarding white spaces:
// http://stackoverflow.com/questions/4300980/what-are-all-the-japanese-whitespace-characters
// http://www.fileformat.info/info/unicode/category/Zs/list.htm
// https://gist.github.com/ryanmcgrath/982242
// https://mathiasbynens.be/notes/javascript-escapes
// https://mothereff.in/js-escapes

// ｦｧｨｩｪｫｬｭｮｯｰｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ
var toFullWidthKana = [
  'ヲ','ァ','ィ','ゥ','ェ','ォ','ャ','ュ','ョ','ｯ','ー','ア','イ','ウ','エ','オ',
  'カ','キ','ク','ケ','コ','サ','シ','ス','セ','ソ','タ','チ','ツ','テ','ト',
  'ナ','ニ','ヌ','ネ','ノ','ハ','ヒ','フ','ヘ','ホ','マ','ミ','ケ','メ','モ',
  'ヤ','ユ','ヨ','ラ','リ','ル','レ','ロ','ワ','ン'
];

var obj = {
  convertHalfWidth: function (str) {
    const normalized = str
      .replace(/[\uff01-\uff5e]/g, // Roman full to ascii
        function(ch) { return String.fromCharCode(ch.charCodeAt(0) - 0xfee0); })
      .replace(/\uff61/g, '.') // Replace space
      .replace(/[\uff66-\uff9d]/g, // To full-width katakana
        function(ch) { return toFullWidthKana[ch.charCodeAt(0) - 0xff66]; })
      .replace(/\u3000/g, ' ')
      ;
    
    return normalized;
  },
  sanitize: function (str) {
    return obj.convertHalfWidth(str);
  },
  SPACE: '[' + [
    ' ', // U+0020, regular space
    '\t', // Tab
    '\u3000', // Ideographic space, aka. full-width space
  ].join('') + ']',
};


module.exports = obj;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TetraPopup = __webpack_require__(3);
var Utils = __webpack_require__(0);

document.addEventListener('DOMContentLoaded', function () {
  // Dependancies
  var body = document.getElementById('test').contentWindow.document;
  var locationBar = document.getElementById('location');
  function nav(e) {
    window.fetch('http://127.0.0.1:8080/' + encodeURI(locationBar.value))
      .then(Utils.responseText)
      .then(x => body.write(x));
    //document.getElementById('test').src = locationBar.value;
  }
  locationBar.addEventListener('keydown',function (e) {
    if (e.keyCode == 13) {
      nav(e);
    }
  });
  document.getElementById('navigate').addEventListener('click', nav);
  //var dictionary = TetraChanDictionaryInterface;
  /*window.fetch('http://127.0.0.1:8080/' + encodeURI('http://jisho.org/api/v1/search/words?keyword=食'))
    .then(Utils.responseJSON)
    .then(x => console.log(x));*/

  var popup = TetraPopup(document.body, undefined, [document.body, body], {
    throttle: 500,
    onCaretChange: function (text) {
      console.log(text);
      /*popup.clear();
      if (text !== "") {
        //dictionary.onlineSearch(text, popup.push,
        //  'http://jisho.org/api/v1/search/words?keyword=');
      }
  //        console.log(dictionary);
  //        console.log(text);*/
    }
  });
  //popup.show();
  //console.log('yo');
});

//module.export = TetraPopup;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {


var Utils = __webpack_require__(0);
var textReader = __webpack_require__(4);

function _makeContainer() {
// Create the div for the popup
  var container = document.createElement('div');
  var style = container.style;
  style.width = '400px';
  style.height = '100px';
  style.position = 'fixed';
  style.left = '0px';
  style.top  = '0px';
  //style.visibility = 'visible';
  style.zIndex = '400';//*/
  style.backgroundColor = '#00FFF0';
  return container;
}

/**
 * @param {HTMLElement} body
 * @param {Object} template
 * @param {Array<HTMLElement>} listeningContexts All the objects to which
 * to attach event handlers
 * @param {Object} options
 * @param {Function} options.onCaretChange
 * @param {number} options.throttle
 */
function TetraPopup(body, template, listeningContexts, options) {
  // Private variables
  var _ = {
    body: body,
    container: _makeContainer(),
    text: '',
    listeners: listeningContexts,
    mouse: undefined,
//      throttle: 100,
  };

  // 
  var settings = Utils.shallowDefaultOverride({
    onCaretChange: Utils.nullFunction,
    throttle: 500,
  }, options);
  
    // Return
  var popup = Object.create(null);

  popup.setOptions = Utils.shallowDefaultOverride.bind(null, settings);

  popup.show = function () {
    _.body.appendChild(_.container);
  };
    
  popup.hide = function () {
    _.body.removeChild(_.container);
    popup.clear();
  };
    
  popup.push = function (template, rank) {
    //_.container.appendChild(template);
    _.container.innerHTML += template;
    console.log(rank);

  };

  popup.clear = function () {
    while (_.container.lastChild) {
      _.container.removeChild(_.container.lastChild);
    }
  };
  
  // Cause good habits, need to come back later and see what i actually need to delete
  popup.clean = function () {
    // Remove event listeners
    _.listeners.forEach(function (obj) {
      obj.removeEventListener('mousemove', popup.throttledMove);
    });

    // Clean up objs?
    Object.getOwnPropertyNames(popup).forEach(function (prop) {
      delete(popup[prop]);
    });
    
    // Clean up private variables, probably don't actually need to do this
    Object.getOwnPropertyNames(_).forEach(function (prop) {
      delete(_[prop]);
    });

  };

  popup.move = function (newText) {
    var caratChange = newText !== _.text;
    _.text = newText;

    if (caratChange) {
      settings.onCaretChange(newText);
    }
  };
  
  var time = Date.now();
  var cooldown = 0;
  var timeoutID;
  
  popup.throttledMove = function (ev) {
    var deltaTime = Date.now() - time;
    time += deltaTime;
    var check = cooldown - deltaTime;

    // Things to run on every event even on throttle cooldown
    var text = textReader.extract(ev, 0); // rangeParent and rangeOffset are affected
    //console.log(text);
    
    if (check < (- options.throttle)) {
      cooldown = 0;
      popup.move(text);
    } else if (check <= 0) { // Falling edge
      cooldown = options.throttle;
      timeoutID = setTimeout(popup.move, options.throttle + check, text);
    } else { // We're on cooldown
      cooldown -= deltaTime;
    }
  };

  // Add event listeners
  _.listeners.forEach(function (obj) {
    obj.addEventListener('mousemove', popup.throttledMove);
  });

  return popup;
}

/*function _need(arg, errorText) {
  if (typeof arg === 'undefined') {
    throw new Error(errorText);
  }
  return arg;
}*/

module.exports = TetraPopup;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// To do:
// - add sanity check to getQuote?
// - implement extract polyfill

var MAX_WORD_LENGTH;
//var asdf = document.getElementById('test').contentWindow.document;
var text = Object.create(null);

text.extract = function (ev, type) {
  if (ev.rangeParent.nodeType != Node.TEXT_NODE) {
    return '';
  }
  return ev.rangeParent.data.substr(ev.rangeOffset, MAX_WORD_LENGTH);
};

text.readRange;
if (true) {
  text.readRange = function (element) {
    var doc = element.ownerDocument || element.document;
    var win = doc.defaultView || doc.parentWindow;
    var sel, range, preCaretRange, caretOffset = 0;
    if (typeof win.getSelection != "undefined") {
      sel = win.getSelection();
      console.log(sel);
      if (sel.rangeCount) {
        range = sel.getRangeAt(0);
        preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        caretOffset = preCaretRange.toString().length;
      }
    }
    return caretOffset;
  };
}

text.getCaretCharacterOffsetWithin = function (element) {
  var doc = element.ownerDocument || element.document;
  var win = doc.defaultView || doc.parentWindow;
  var sel, range, preCaretRange, caretOffset = 0;
  if (typeof win.getSelection != "undefined") {
      sel = win.getSelection();
      if (sel.rangeCount) {
          range = sel.getRangeAt(0);
          preCaretRange = range.cloneRange();
          preCaretRange.selectNodeContents(element);
          preCaretRange.setEnd(range.endContainer, range.endOffset);
          caretOffset = preCaretRange.toString().length;
      }
  } else if ( (sel = doc.selection) && sel.type != "Control") {
      range = doc.selection.createRange();
      preCaretRange = doc.body.createTextRange();
      preCaretRange.moveToElementText(element);
      preCaretRange.setEndPoint("EndToEnd", textRange);
      caretOffset = preCaretTextRange.text.length;
  }
  return caretOffset;
}; 
text.read = function (ev) {
  var range;
  var textNode;
  var offset;

  if (document.caretPositionFromPoint) { // Standard
    range = document.caretPositionFromPoint(ev.clientX, ev.clientY);
    textNode = range.offsetNode;
    offset = range.offset;
      
  } else if (document.caretRangeFromPoint) { // Webkit
    range = document.caretRangeFromPoint(ev.clientX, ev.clientY);
    textNode = range.startContainer;
    offset = range.startOffset;
  } else {
    throw new Error('Need to polyfill caretRangeFromPoint');
  }
  return range;
};

// Functions as the polyfill for document.caretPositionFromPoint
function extract(event) {
  let range = document.caretPositionFromPoint(event.clientX, event.clientY);
  return range;
/*  const element = document.elementFromPoint(point.x, point.y);
  if (element !== null) {
    if (element.nodeName === 'IMG' || element.nodeName === 'BUTTON') {
      return new TextSourceElement(element);
    } else if (imposter && (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA')) {
      docImposterCreate(element);
    }
  }

  //range = document.caretPositionFromPoint === undefine
  if (!document.caretRangeFromPoint) {
      document.caretRangeFromPoint = (x, y) => {
          const position = document.caretPositionFromPoint(x,y);
          if (position === null) {
              return null;
          }

          const range = document.createRange();
          range.setStart(position.offsetNode, position.offset);
          range.setEnd(position.offsetNode, position.offset);
          return range;
      };
  } else {}

  const range = document.caretRangeFromPoint(point.x, point.y);
  if (range !== null) {
      return new TextSourceRange(range);
  }

  return null;
//*/

}

module.exports = text;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(2);


/***/ })
/******/ ]);